import com.chaquo.python.Common;

apply plugin: 'java-gradle-plugin'
apply plugin: 'groovy'

group = "com.chaquo.python"

gradlePlugin {
    plugins {
        gradle {
            id = "com.chaquo.python"
            implementationClass = "com.chaquo.python.PythonPlugin"

            // For these fields, the `pom` block in the root build.gradle doesn't have any
            // effect on the plugin marker artifact.
            displayName = "Chaquopy"
            description = "The Python SDK for Android"
        }
    }
}

dependencies {
    implementation localGroovy()
    implementation "org.apache.commons:commons-compress:1.18"
    implementation "org.json:json:20160810"

    testImplementation "junit:junit:4.12"
}

sourceCompatibility = 7
sourceSets.main.java.srcDirs += ["../buildSrc/src/main/java"]

task("zipBuildPackages", type: Zip) {
    destinationDirectory = file("$buildDir/tmp/$name")
    archiveFileName = "build-packages.zip"
    from "src/main/python"
    exclude "**/*.pyc"
}

processResources {
    doFirst { delete destinationDir }
    into("com/chaquo/python/gradle") {
        from zipBuildPackages
    }
}

// Don't use the Exec task: on Windows, it causes the integration tests to hang if they spawn a
// Gradle daemon, because their stdout is inherited by the daemon and will therefore never
// close (https://github.com/gradle/gradle/issues/3987). This can be reproduced more simply
// with the command `cmd /c start notepad.exe`: cmd will exit, but the Exec task won't
// complete until you close Notepad.
Task testPythonTask(String name, String version, Closure closure) {
    def t = task(name, "group": "verification") {
        def pb = new ProcessBuilder()
        def command = new ArrayList<String>()

        // Emulate the necessary Exec methods.
        ext.workingDir = { dir -> pb.directory(file(dir)) }
        ext.environment = { String key, String value -> pb.environment().put(key, value) }
        ext.args = { String... args -> command.addAll(args) }

        if (System.properties['os.name'].toLowerCase().contains('windows')) {
            args "py", "-$version"
        } else {
            args "python$version"
        }
        args "-m", "unittest"
        if (project.hasProperty("testPythonArgs")) {
            args project.testPythonArgs.split(" ")
        } else {
            args "discover", "-v"
        }

        outputs.upToDateWhen { false }
        doLast {
            pb.command(command)
            pb.redirectErrorStream(true)  // Merge stdout and stderr.
            def process = pb.start()

            // pb.inheritIO() doesn't seem to prevent stdout from blocking. Even if it did, the
            // output would be lost because it would inherit the Gradle daemon's *native*
            // stdout, which isn't connected to anything.
            //
            // So we capture the output manually and send it to System.out, which is connected
            // to the Gradle client. In case isAlive() returns true with data still buffered,
            // we keep on reading after the process exits until no more data is available.
            def stdout = process.getInputStream()  // sic
            def buffer = new byte[1024]
            def available = 0
            while ((available = stdout.available()) > 0 || process.isAlive()) {
                if (available > 0) {
                    def len = stdout.read(buffer, 0, Math.min(available, buffer.length))
                    System.out.write(buffer, 0, len)
                    System.out.flush()
                } else {
                    Thread.sleep(100)
                }
            }
            def status = process.waitFor()
            if (status != 0) {
                throw new GradleException("Exit status $status")
            }
        }
    }
    closure.delegate = t
    closure()
    return t
}

// Test on the minimum supported buildPython version.
testPythonTask("testPython", "3.7") {
    workingDir "$projectDir/src/test/python"
}
check.dependsOn(testPython)


task("testIntegration", "group": "verification")
check.dependsOn(testIntegration)

def INTEGRATION_DIR = "$projectDir/src/test/integration"
for (f in file("$INTEGRATION_DIR/data").listFiles()) {
    (f.name =~ /^base-(.+)$/).collect {
        def version = it[1]
        def task = testPythonTask("testIntegration-$version",
                                  Common.DEFAULT_PYTHON_VERSION) {
            if (System.getenv("CHAQUOPY_NO_BUILD") == null) {  // Used in CI
                dependsOn publish, ":runtime:publish"
            }
            workingDir INTEGRATION_DIR
            environment "CHAQUOPY_AGP_VERSION", version
        }
        testIntegration.dependsOn(task)
    }
}


jar {
    manifest {
        // Enables getClass().getPackage().getImplementationVersion(), which PythonPlugin uses
        // to discover its own version number.
        attributes 'Implementation-Version': project.version
    }
}
