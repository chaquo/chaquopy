import com.chaquo.python.Common;

group = "com.chaquo.python.runtime"


def osNameProperty = System.properties['os.name']
String osName = null
for (name in ["linux", "mac", "windows"]) {
    if (osNameProperty.toLowerCase(Locale.ENGLISH).startsWith(name)) {
        osName = name
        break
    }
}
if (osName == null) {
    throw new GradleException("unknown os.name: '$osNameProperty'")
}

def pyPlusVersion = "python$Common.DEFAULT_PYTHON_VERSION"
// filenames with dots require the ".exe" suffix with Exec tasks on Windows.
def pyPlusVersionExe = "$pyPlusVersion"
if (osName == "windows") {
    pyPlusVersionExe += ".exe"
}
pyPlusVersionExe = findOnPath(pyPlusVersionExe)


// The default PATH on Mac is /usr/bin:/bin:/usr/sbin:/sbin. However, apps can't install
// anything into these locations, so the python.org installers use /usr/local/bin
// instead. This directory may also appear to be on the default PATH, but this is
// because it's listed in /etc/paths, which only affects shells, not other apps like
// Android Studio, or its Gradle subprocesses.
String findOnPath(String basename) {
    def path = System.getenv("PATH").split(File.pathSeparator) + ["/usr/local/bin"]
    for (dir in path) {
        def file = new File(dir, basename)
        if (file.exists()) {
            return file.toString()
        }
    }
    throw new GradleException("Couldn't find '$basename' on PATH")
}

String pythonHome
if (osName == "windows" && System.getenv("CI") != null) {
    // All the tasks that use pythonHome require MSYS2 Python on Windows, but we don't
    // install that in CI because we don't run any of those tasks. TODO: fix this by
    //  moving to the standard Windows Python builds.
    pythonHome = "disabled/in/CI"
} else {
    new ByteArrayOutputStream().withStream { output ->
        exec {
            executable pyPlusVersionExe
            args "-c", "import sys; print(sys.base_prefix)"
            standardOutput = output
        }
        pythonHome = output.toString().trim()
    }
}


void addArtifact(Task task, Object filename, String pyVersion=null, String abi=null) {
    File f = file(filename)
    def dotPos = f.name.lastIndexOf(".")
    def dashPos = f.name.indexOf("-")
    def name = f.name.substring(0, (dashPos != -1) ? dashPos : dotPos)
    def pub = publishing.publications.maybeCreate(name, MavenPublication)
    pub.artifactId = name
    pub.artifact(f) {
        builtBy task
        def classifiers = [pyVersion, abi].findAll { it != null }
        if (!classifiers.isEmpty()) {
            setClassifier(classifiers.join("-"))
        }
        extension f.name.substring(dotPos + 1)
    }
}

sourceSets.main.java.srcDirs += ["../buildSrc/src/main/java"]
sourceCompatibility = 7
publishing {
    publications {
        chaquopy_java(MavenPublication) {
            artifactId name
            from components.java
        }
    }
}


Common.PYTHON_VERSIONS_SHORT.each { pyVersion ->
    def compilePython = task("compilePython-$pyVersion", type: Copy, group: "build") {
        doFirst {
            delete(destinationDir)
            mkdir(destinationDir)
        }
        from "src/main/python"
        into "$buildDir/$Common.ASSET_BOOTSTRAP/$pyVersion"
        include "**/*.py"
        include "**/*.dist-info/**"  // For license files

        includeEmptyDirs false
        doLast {
            exec {
                workingDir destinationDir
                if (osName == "windows") {
                    commandLine findOnPath("py"), "-$pyVersion"
                } else {
                    commandLine findOnPath("python$pyVersion")
                }
                args "-m", "compileall"
                args "-q", "-b", "."
            }
            delete fileTree(destinationDir) {
                include "**/*.py"
            }
        }
    }

    def zipPython = task("zipPython-$pyVersion", type: Zip, group: "build") {
        from compilePython
        destinationDirectory = new File(buildDir, Common.ASSET_BOOTSTRAP)
        archiveFileName = Common.assetZip("$Common.ASSET_BOOTSTRAP-$pyVersion")
        preserveFileTimestamps = false
        reproducibleFileOrder = true
    }
    addArtifact(zipPython, zipPython.archivePath, pyVersion)
}

// The following properties file should be created manually, as described in
// product/README.md. It's also used in test_gradle_plugin.py.
String getLocalProperty(String key, String defaultValue = null) {
    def localProps = new Properties()
    localProps.load(project.rootProject.file('local.properties').newDataInputStream())
    def result = localProps.getProperty(key, defaultValue)
    if (result == null) {
        throw new GradleException("'$key' is missing from local.properties")
    }
    return result
}

String sdkPath(String path) {
    def sdkDir = System.getenv("ANDROID_HOME")
    if (sdkDir == null) {
        try {
            sdkDir = getLocalProperty("sdk.dir")
        } catch (GradleException e) {
            throw new GradleException(
                "SDK location not found. Define location with sdk.dir in the " +
                "local.properties file or with an ANDROID_HOME environment variable.")
        }
    }
    def absPath = "$sdkDir/$path"
    if (!file(absPath).exists()) {
        throw new GradleException("$path not found: install it using the SDK Manager")
    }
    return absPath
}

// Android Studio 4.2 no longer comes with JNI headers, so build against an older JRE. Also,
// some of the Python unit tests don't work on Java 11 yet (#5727).
//
// This does not affect the Java unit tests, which will use the same Java as Gradle itself.
def javaHome = getLocalProperty('chaquopy.java.home.8')

task("doc", group: "documentation")

javadoc {
    destinationDir = file("$docsDir/java")
    title "Chaquopy Java API"
    options {
        addStringOption("source", "8")
        addBooleanOption("Xdoclint:all,-missing", true)
        addBooleanOption("nodeprecated", true)
        addStringOption("link", "https://developer.android.com/reference/")
    }
}
doc.dependsOn(javadoc)


def cythonTask = {Map taskArgs=[:], String name, Closure closure ->
    taskArgs["type"] = Exec
    taskArgs.putIfAbsent("group", "build")
    def t = task(taskArgs, name, closure)
    t.configure {
        def pyxFiles = inputs.files.findAll { it.name.endsWith(".pyx") }
        assert(pyxFiles.size() == 1)
        def inFile = pyxFiles.get(0)
        def stem = inFile.name.substring(0, inFile.name.length() - ".pyx".length())
        def outDir = "$buildDir/cython"
        def outFile = "$outDir/${stem}.c"
        outputs.file outFile

        workingDir inFile.parent  // Reduce clutter in exception traces
        executable findOnPath("cython")
        args "-Wextra", "-Werror", inFile.name, "-I", outDir, "-o", outFile

        doLast {
            String[][] replacements = [
                // All functions called directly by the JVM must be declared JNICALL JNIEXPORT. JNIEXPORT
                // should be equivalent to Cython's "cdef public", but JNICALL does make a difference on
                // some platforms including x86. So alter the generated C code to add it.
                [/^__PYX_EXTERN_C (\w+)/,
                 '/* cythonTask altered */ __PYX_EXTERN_C JNIEXPORT $1 JNICALL'],

                // Workaround for https://github.com/cython/cython/issues/3725.
                [/__pyx_insert_code_object\(c_line/,
                 '// cythonTask disabled: $0'],
            ]
            def cFile = outputs.files.getSingleFile()
            def tmpFile = new File("${cFile}.tmp")
            tmpFile.withWriter { writer ->
                for (line in cFile.readLines()) {
                    for (r in replacements) {
                        line = line.replaceAll(r[0], r[1])
                    }
                    writer.write(line + "\n")
                }
            }
            if (! (cFile.delete() && tmpFile.renameTo(cFile))) {
                throw new GradleException("Failed to replace $cFile")
            }
        }

    }
    return t
}

cythonTask("cythonPython") {
    inputs.files fileTree("$projectDir/src/main/python/java") {
        include "chaquopy.pyx", "*.pxi", "*.pxd"
    }
}
cythonTask("cythonJava") {
    inputs.files fileTree("$projectDir/src/main/python") {
        include "chaquopy_java.pyx", "java/*.pxd"
    }
}

def sdkCmakeDir = sdkPath("cmake/3.22.1")  // Should match the version in the root Dockerfile.
def androidJar = "${sdkPath("platforms/android-" + Common.COMPILE_SDK_VERSION)}/android.jar"

dependencies {
    compileOnly files(androidJar)
    implementation 'org.jetbrains:annotations-java5:15.0'

    testCompileOnly files(androidJar)
    testImplementation 'junit:junit:4.12'
    testImplementation 'org.hamcrest:hamcrest-library:2.2'
}

task("generateStaticProxy", type: Exec, group: "verification") {
    def outputDir = "$buildDir/static_proxy"
    outputs.dir(outputDir)
    outputs.upToDateWhen { false }
    doFirst { delete outputDir }
    environment "PYTHONPATH", "$projectDir/../gradle-plugin/src/main/python"
    executable pyPlusVersionExe
    args "-m", "chaquopy.static_proxy"
    args "--path", "$projectDir/src/test/python"
    args "--java", outputDir
    args("chaquopy.test.static_proxy.basic", "chaquopy.test.static_proxy.header",
         "chaquopy.test.static_proxy.method")
}
sourceSets.test.java.srcDirs += generateStaticProxy.outputs

for (abi in ["host"] + Common.ABIS) {
    def pyLibSuffix = ".so"
    def cmakeBuildSubdir = "$buildDir/cmake/$abi"
    def cmakeBuildType = findProperty("cmakeBuildType") ?: "Debug"
    def cmake = task("cmake-$abi", type: Exec, group: "build") {
        dependsOn cythonPython, cythonJava
        inputs.files "CMakeLists.txt"
        // This is not a complete list of the outputs, but it's enough to detect when the
        // directory has been deleted. We can't declare the whole directory as an output,
        // because the cmakeBuild task outputs to the same place.
        outputs.files "$cmakeBuildSubdir/build.ninja", "$cmakeBuildSubdir/rules.ninja",
                      "$cmakeBuildSubdir/CMakeCache.txt"
        doFirst {
            // This is the only reliable way to pick up changes to args. For example,
            // attempting to change CMAKE_TOOLCHAIN_FILE in an existing build tree will be
            // silently ignored.
            delete cmakeBuildSubdir
            mkdir cmakeBuildSubdir
        }
        workingDir cmakeBuildSubdir
        executable "$sdkCmakeDir/bin/cmake"
        args "-GNinja", "-DCMAKE_MAKE_PROGRAM=$sdkCmakeDir/bin/ninja",
             "-DCMAKE_BUILD_TYPE=$cmakeBuildType",
             "-DCHAQUOPY_SRC_DIR=build/cython"

        if (abi == "host") {
            String javaIncludeSubdir
            if (osName == "windows") {
                pyLibSuffix = ".pyd"
                javaIncludeSubdir = "win32"
            } else if (osName == "mac") {
                javaIncludeSubdir = "darwin"
            } else {
                javaIncludeSubdir = osName
            }
            args "-DCHAQUOPY_PYTHON_VERSION=$Common.DEFAULT_PYTHON_VERSION"
            args "-DCHAQUOPY_LIB_DIRS=$pythonHome/lib"
            args "-DCHAQUOPY_INCLUDE_PYTHON=$pythonHome/include"
            args ("-DCHAQUOPY_INCLUDE_JAVA=$javaHome/include;" +
                  "$javaHome/include/$javaIncludeSubdir")
        } else {
            // This must be one of the NDK versions which are pre-installed on the
            // GitHub Actions runner. Ideally it would also match the version in
            // target/build-common.sh, but the latter is more difficult to change.
            def ndkDir = sdkPath("ndk/23.2.8568313")
            def prefixDir = "$projectDir/../../target/prefix/$abi"
            args "-DCMAKE_TOOLCHAIN_FILE=$ndkDir/build/cmake/android.toolchain.cmake",
                 "-DANDROID_ABI=$abi", "-DANDROID_STL=system",
                 "-DANDROID_NATIVE_API_LEVEL=$Common.MIN_SDK_VERSION",
                 "-DCHAQUOPY_PYTHON_VERSIONS=${Common.PYTHON_VERSIONS_SHORT.join(';')}",
                 "-DCHAQUOPY_INCLUDE_PYTHON=$prefixDir/include",
                 "-DCHAQUOPY_LIB_DIRS=$prefixDir/lib"
        }
        args "-DCHAQUOPY_PY_SUFFIX=$pyLibSuffix",
             projectDir
    }

    def cmakeBuild = task("cmakeBuild-$abi", type: Exec, group: "build") {
        // No inputs or outputs: the command itself determines whether it's up to date.
        dependsOn cmake
        executable "$sdkCmakeDir/bin/cmake"
        args "--build", cmakeBuildSubdir
    }
    if (abi != "host") {
        for (name in ["chaquopy", "libchaquopy_java"]) {
            for (pyVersion in Common.PYTHON_VERSIONS_SHORT) {
                addArtifact(cmakeBuild, "$cmakeBuildSubdir/$name-${pyVersion}.so",
                            pyVersion, abi)
            }
        }
    }

    if (abi == "host") {
        def mainPythonDir = "$projectDir/src/main/python"
        def testPythonDir = "$projectDir/src/test/python"
        task("setupPythonPath", group: "verification") {
            dependsOn cmakeBuild
            doFirst {
                copy {
                    into mainPythonDir
                    from(cmakeBuildSubdir) {
                        include "chaquopy${pyLibSuffix}"
                        into "java"
                    }
                }
            }
        }

        def testCommonConfig = {
            dependsOn setupPythonPath, compileTestJava
            environment "CLASSPATH", sourceSets.test.runtimeClasspath.asPath

            // Can't use -Djava.library.path because we need something which also works
            // for Python processes.
            def pathVar = (osName == "windows") ? "PATH"
                          : (osName == "mac") ? "DYLD_LIBRARY_PATH"
                          : "LD_LIBRARY_PATH"
            environment pathVar, (cmakeBuildSubdir + File.pathSeparator +
                                  (System.getenv(pathVar) ?: ""))
            environment "PYTHONPATH", mainPythonDir + File.pathSeparator + testPythonDir
        }

        // For consistency with Android demo app, run via test suite rather than using
        // "discover".
        task("testPython", type: Exec, group: "verification") {
            workingDir "$projectDir/src/test/python"
            environment "JAVA_HOME", javaHome
            executable pyPlusVersionExe
            args "-m", "unittest"
            if (project.hasProperty("testPythonArgs")) {
                args project.testPythonArgs.split(" ")
            } else {
                args "chaquopy.test"
            }
        }
        testPython.configure(testCommonConfig)
        check.dependsOn(testPython)

        compileTestJava {
            sourceCompatibility = "1.8"
            targetCompatibility = "1.8"
        }

        // Run via test suite for consistency with Android demo app. (NOTE: this will not show
        // test results within IntelliJ for some reason.)
        test.exclude "**"  // Disable the default test task
        task("testJava", type: Test, group: "verification") {
            outputs.upToDateWhen { false }
            environment "PYTHONHOME", pythonHome
            if (osName == "linux") {
                // libchaquopy_java.so is linked against libpython, but that doesn't add
                // the libpython symbols to the global scope, which is required in order to
                // load native modules like ctypes. Loading libpython with
                // System.loadLibrary doesn't help: presumably it uses RTLD_LOCAL on
                // Linux. Altering chaquopy_java to call dlopen with RTLD_GLOBAL would be
                // the proper solution, but let's do it the easy way for now. See #5695.
                environment "LD_PRELOAD", "/usr/lib/x86_64-linux-gnu/lib${pyPlusVersion}.so"
            }
            testClassesDirs = sourceSets.test.output.classesDirs
            scanForTestClasses = false
            include "**/TestSuite.class"
            testLogging {
                exceptionFormat = 'full'
                showStandardStreams = true
            }
        }
        testJava.configure(testCommonConfig)
        check.dependsOn(testJava)

        // Generates a script to start a Python REPL with Java and Python paths set up.
        task("consoleScript") {
            dependsOn setupPythonPath
            doLast {
                def writer = new PrintWriter("$projectDir/console.sh")
                writer.println "#!/bin/bash -e"
                writer.println "# Generated by Gradle consoleScript task"
                def env = testPython.environment
                for (String key : ["CLASSPATH", "PYTHONPATH"]) {
                    writer.println "export $key='${env.get(key)}'"
                }
                writer.println "export PATH=\"$cmakeBuildSubdir${File.pathSeparator}" + '$PATH"'
                writer.println "winpty $pyPlusVersionExe " + '"$@"'
                writer.close()
            }
        }

        // Requires the Python packages in requirements-docs.txt.
        task("sphinx", type: Exec, group: "documentation") {
            // We call a specific Python executable rather than running `sphinx-build`,
            // because Sphinx needs to be able to import the runtime module.
            executable pyPlusVersionExe
            args "-m", "sphinx", "-v", "-b", "html", "docs/sphinx", "build/docs"
            environment "JAVA_HOME", javaHome
        }
        sphinx.configure(testCommonConfig)
        doc.dependsOn(sphinx)
    }
}
