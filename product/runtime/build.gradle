import com.chaquo.python.Common;

group = "com.chaquo.python.runtime"


// See product/README.md for Windows build instructions.
def windowsHost = System.properties['os.name'].toLowerCase().contains('windows')
def mingwDir = windowsHost ? getLocalProperty('mingw.dir') : null

void addArtifact(Task task, Object filename, String pyVersion=null, String abi=null) {
    File f = file(filename)
    def dotPos = f.name.lastIndexOf(".")
    def dashPos = f.name.indexOf("-")
    def name = f.name.substring(0, (dashPos != -1) ? dashPos : dotPos)
    def pub = publishing.publications.maybeCreate(name, MavenPublication)
    pub.artifactId = name
    pub.artifact(f) {
        builtBy task
        def classifiers = [pyVersion, abi].findAll { it != null }
        if (!classifiers.isEmpty()) {
            setClassifier(classifiers.join("-"))
        }
        extension f.name.substring(dotPos + 1)
    }
}

sourceSets.main.java.srcDirs += ["../buildSrc/src/main/java"]
sourceCompatibility = 7
publishing {
    publications {
        chaquopy_java(MavenPublication) {
            artifactId name
            from components.java
        }
    }
}


Common.PYTHON_VERSIONS_SHORT.each { pyVersion ->
    def compilePython = task("compilePython-$pyVersion", type: Copy, group: "build") {
        doFirst {
            delete(destinationDir)
            mkdir(destinationDir)
        }
        from "src/main/python"
        into "$buildDir/$Common.ASSET_BOOTSTRAP/$pyVersion"
        include "**/*.py"
        include "**/*.dist-info/**"  // For license files

        includeEmptyDirs false
        doLast {
            exec {
                workingDir destinationDir
                if (windowsHost) {
                    commandLine "py", "-$pyVersion"
                } else {
                    commandLine "python$pyVersion"
                }
                args "-m", "compileall"
                args "-q", "-b", "."
            }
            delete fileTree(destinationDir) {
                include "**/*.py"
            }
        }
    }

    def zipPython = task("zipPython-$pyVersion", type: Zip, group: "build") {
        from compilePython
        destinationDirectory = new File(buildDir, Common.ASSET_BOOTSTRAP)
        archiveFileName = Common.assetZip("$Common.ASSET_BOOTSTRAP-$pyVersion")
        preserveFileTimestamps = false
        reproducibleFileOrder = true
    }
    addArtifact(zipPython, zipPython.archivePath, pyVersion)
}

// The following properties file should be created manually. It's also used in
// test_gradle_plugin.py.
String getLocalProperty(String key, String defaultValue = null) {
    def localProps = new Properties()
    localProps.load(project.rootProject.file('local.properties').newDataInputStream())
    def result = localProps.getProperty(key, defaultValue)
    if (result == null) {
        throw new GradleException("'$key' is missing from local.properties")
    }
    return result
}

def sdkDir = getLocalProperty('sdk.dir')
def ndkDir = "$sdkDir/ndk/22.1.7171670"  // Should match the version in target/build-common.sh.

// Android Studio 4.2 no longer comes with JNI headers, so build against an older JRE. Also,
// some of the Python unit tests don't work on Java 11 yet (#5727).
//
// This does not affect the Java unit tests, which will use the same Java as Gradle itself.
def javaHome = getLocalProperty('chaquopy.java.home.8')

task("doc", group: "documentation")

javadoc {
    destinationDir = file("$docsDir/java")
    title "Chaquopy Java API"
    options {
        addStringOption("source", "8")
        addBooleanOption("Xdoclint:all,-missing", true)
        addBooleanOption("nodeprecated", true)
        addStringOption("link", "https://developer.android.com/reference/")
    }
}
doc.dependsOn(javadoc)


def cythonTask = {Map taskArgs=[:], String name, Closure closure ->
    taskArgs["type"] = Exec
    taskArgs.putIfAbsent("group", "build")
    def t = task(taskArgs, name, closure)
    t.configure {
        def pyxFiles = inputs.files.findAll { it.name.endsWith(".pyx") }
        assert(pyxFiles.size() == 1)
        def inFile = pyxFiles.get(0)
        def stem = inFile.name.substring(0, inFile.name.length() - ".pyx".length())
        def outDir = "$buildDir/cython"
        def outFile = "$outDir/${stem}.c"
        outputs.file outFile

        workingDir inFile.parent  // Reduce clutter in exception traces
        executable "cython"
        args "-Wextra", "-Werror", inFile.name, "-I", outDir, "-o", outFile

        doLast {
            String[][] replacements = [
                // All functions called directly by the JVM must be declared JNICALL JNIEXPORT. JNIEXPORT
                // should be equivalent to Cython's "cdef public", but JNICALL does make a difference on
                // some platforms including x86. So alter the generated C code to add it.
                [/^__PYX_EXTERN_C (\w+)/,
                 '/* cythonTask altered */ __PYX_EXTERN_C JNIEXPORT $1 JNICALL'],

                // Workaround for https://github.com/cython/cython/issues/3725.
                [/__pyx_insert_code_object\(c_line/,
                 '// cythonTask disabled: $0'],
            ]
            def cFile = outputs.files.getSingleFile()
            def tmpFile = new File("${cFile}.tmp")
            tmpFile.withWriter { writer ->
                for (line in cFile.readLines()) {
                    for (r in replacements) {
                        line = line.replaceAll(r[0], r[1])
                    }
                    writer.write(line + "\n")
                }
            }
            if (! (cFile.delete() && tmpFile.renameTo(cFile))) {
                throw new GradleException("Failed to replace $cFile")
            }
        }

    }
    return t
}

cythonTask("cythonPython") {
    inputs.files fileTree("$projectDir/src/main/python/java") {
        include "chaquopy.pyx", "*.pxi", "*.pxd"
    }
}
cythonTask("cythonJava") {
    inputs.files fileTree("$projectDir/src/main/python") {
        include "chaquopy_java.pyx", "java/*.pxd"
    }
}

def sdkCmakeDir = "$sdkDir/cmake/3.22.1"  // Should match the version in the root Dockerfile.

def androidJar = "$sdkDir/platforms/android-$Common.COMPILE_SDK_VERSION/android.jar"
if (!file(androidJar).exists()) {
    throw new GradleException("Android SDK Platform $Common.COMPILE_SDK_VERSION not found: " +
                              "install it using the SDK Manager")
}

dependencies {
    compileOnly files(androidJar)
    implementation 'org.jetbrains:annotations-java5:15.0'

    testCompileOnly files(androidJar)
    testImplementation 'junit:junit:4.12'
    testImplementation 'org.hamcrest:hamcrest-library:2.2'
}

task("generateStaticProxy", type: Exec, group: "verification") {
    def outputDir = "$buildDir/static_proxy"
    outputs.dir(outputDir)
    outputs.upToDateWhen { false }
    doFirst { delete outputDir }
    environment "PYTHONPATH", "$projectDir/../gradle-plugin/src/main/python"
    executable "python3"
    args "-m", "chaquopy.static_proxy"
    args "--path", "$projectDir/src/test/python"
    args "--java", outputDir
    args("chaquopy.test.static_proxy.basic", "chaquopy.test.static_proxy.header",
         "chaquopy.test.static_proxy.method")
}
sourceSets.test.java.srcDirs += generateStaticProxy.outputs

for (abi in ["host"] + Common.ABIS) {
    def pyLibSuffix = ".so"
    def cmakeBuildSubdir = "$buildDir/cmake/$abi"
    def cmakeBuildType = findProperty("cmakeBuildType") ?: "Debug"
    def cmake = task("cmake-$abi", type: Exec, group: "build") {
        dependsOn cythonPython, cythonJava
        inputs.files "CMakeLists.txt"
        // This is not a complete list of the outputs, but it's enough to detect when the
        // directory has been deleted. We can't declare the whole directory as an output,
        // because the cmakeBuild task outputs to the same place.
        outputs.files "$cmakeBuildSubdir/build.ninja", "$cmakeBuildSubdir/rules.ninja",
                      "$cmakeBuildSubdir/CMakeCache.txt"
        doFirst {
            // This is the only reliable way to pick up changes to args. For example,
            // attempting to change CMAKE_TOOLCHAIN_FILE in an existing build tree will be
            // silently ignored.
            delete cmakeBuildSubdir
            mkdir cmakeBuildSubdir
        }
        workingDir cmakeBuildSubdir
        executable "$sdkCmakeDir/bin/cmake"
        args "-GNinja", "-DCMAKE_MAKE_PROGRAM=$sdkCmakeDir/bin/ninja",
             "-DCMAKE_BUILD_TYPE=$cmakeBuildType",
             "-DCHAQUOPY_SRC_DIR=build/cython"

        if (abi == "host") {
            args "-DCHAQUOPY_PYTHON_VERSION=$Common.DEFAULT_PYTHON_VERSION"
            if (windowsHost) {
                pyLibSuffix = ".pyd"
                args "-DCHAQUOPY_INCLUDE_PYTHON=$mingwDir/include"
                args "-DCHAQUOPY_INCLUDE_JAVA=$javaHome/include;$javaHome/include/win32"
            } else {
                // TODO #5482: support Mac
                // TODO: This won't work for installations in /usr/local, or via pyenv.
                args "-DCHAQUOPY_INCLUDE_PYTHON=/usr/include"
                args "-DCHAQUOPY_INCLUDE_JAVA=$javaHome/include;$javaHome/include/linux"
            }
        } else {
            def prefixDir = "$projectDir/../../target/prefix/$abi"
            args "-DCMAKE_TOOLCHAIN_FILE=$ndkDir/build/cmake/android.toolchain.cmake",
                 "-DANDROID_ABI=$abi", "-DANDROID_STL=system",
                 "-DANDROID_NATIVE_API_LEVEL=$Common.MIN_SDK_VERSION",
                 "-DCHAQUOPY_PYTHON_VERSIONS=${Common.PYTHON_VERSIONS_SHORT.join(';')}",
                 "-DCHAQUOPY_INCLUDE_PYTHON=$prefixDir/include",
                 "-DCHAQUOPY_LIB_DIRS=$prefixDir/lib"
        }
        args "-DCHAQUOPY_PY_SUFFIX=$pyLibSuffix",
             projectDir
    }

    def cmakeBuild = task("cmakeBuild-$abi", type: Exec, group: "build") {
        // No inputs or outputs: the command itself determines whether it's up to date.
        dependsOn cmake
        executable "$sdkCmakeDir/bin/cmake"
        args "--build", cmakeBuildSubdir
    }
    if (abi != "host") {
        for (name in ["chaquopy", "libchaquopy_java"]) {
            for (pyVersion in Common.PYTHON_VERSIONS_SHORT) {
                addArtifact(cmakeBuild, "$cmakeBuildSubdir/$name-${pyVersion}.so",
                            pyVersion, abi)
            }
        }
    }

    if (abi == "host") {
        def mainPythonDir = "$projectDir/src/main/python"
        def testPythonDir = "$projectDir/src/test/python"
        task("setupPythonPath", group: "verification") {
            dependsOn cmakeBuild
            doFirst {
                copy {
                    into mainPythonDir
                    from(cmakeBuildSubdir) {
                        include "chaquopy${pyLibSuffix}"
                        into "java"
                    }
                }
            }
        }

        def testCommonConfig = {
            dependsOn setupPythonPath, compileTestJava
            environment "CLASSPATH", sourceSets.test.runtimeClasspath.asPath

            // Can't use -Djava.library.path because we need something which also works
            // for Python processes.
            def pathVar = windowsHost ? "PATH" : "LD_LIBRARY_PATH"
            environment pathVar, (cmakeBuildSubdir + File.pathSeparator +
                                  (System.getenv(pathVar) ?: ""))
            environment "PYTHONHOME", windowsHost ? mingwDir : "/usr"
            environment "PYTHONPATH", mainPythonDir + File.pathSeparator + testPythonDir
        }

        def pyPlusVersion = "python$Common.DEFAULT_PYTHON_VERSION"
        // filenames with dots require the ".exe" suffix with Exec tasks on Windows.
        def pyPlusVersionExe = "$pyPlusVersion"
        if (windowsHost) {
            pyPlusVersionExe += ".exe"
        }

        // For consistency with Android demo app, run via test suite rather than using
        // "discover".
        task("testPython", type: Exec, group: "verification") {
            workingDir "$projectDir/src/test/python"
            environment "JAVA_HOME", javaHome
            executable pyPlusVersionExe
            args "-m", "unittest"
            if (project.hasProperty("testPythonArgs")) {
                args project.testPythonArgs.split(" ")
            } else {
                args "chaquopy.test"
            }
        }
        testPython.configure(testCommonConfig)
        check.dependsOn(testPython)

        compileTestJava {
            sourceCompatibility = "1.8"
            targetCompatibility = "1.8"
        }

        // Run via test suite for consistency with Android demo app. (NOTE: this will not show
        // test results within IntelliJ for some reason.)
        test.exclude "**"  // Disable the default test task
        task("testJava", type: Test, group: "verification") {
            outputs.upToDateWhen { false }
            if (!windowsHost) {
                // libchaquopy_java.so is linked against libpython, but that doesn't add
                // the libpython symbols to the global scope, which is required in order to
                // load native modules like ctypes. Loading libpython with
                // System.loadLibrary doesn't help: presumably it uses RTLD_LOCAL on
                // Linux. Altering chaquopy_java to call dlopen with RTLD_GLOBAL would be
                // the proper solution, but let's do it the easy way for now.
                //
                // TODO #5482: support Mac
                environment "LD_PRELOAD", "/usr/lib/x86_64-linux-gnu/lib${pyPlusVersion}.so"
            }
            testClassesDirs = sourceSets.test.output.classesDirs
            scanForTestClasses = false
            include "**/TestSuite.class"
            testLogging {
                exceptionFormat = 'full'
                showStandardStreams = true
            }
        }
        testJava.configure(testCommonConfig)
        check.dependsOn(testJava)

        // Generates a script to start a Python REPL with Java and Python paths set up.
        task("consoleScript") {
            dependsOn setupPythonPath
            doLast {
                def writer = new PrintWriter("$projectDir/console.sh")
                writer.println "#!/bin/bash -e"
                writer.println "# Generated by Gradle consoleScript task"
                def env = testPython.environment
                for (String key : ["CLASSPATH", "PYTHONPATH"]) {
                    writer.println "export $key='${env.get(key)}'"
                }
                writer.println "export PATH=\"$cmakeBuildSubdir${File.pathSeparator}" + '$PATH"'
                writer.println "winpty $pyPlusVersionExe " + '"$@"'
                writer.close()
            }
        }

        task("sphinx", type: Exec, group: "documentation") {
            // We call a specific Python executable rather than running `sphinx-build`,
            // because Sphinx needs to be able to import the runtime module.
            executable pyPlusVersionExe
            args "-m", "sphinx", "-v", "-b", "html", "docs/sphinx", "build/docs"
        }
        sphinx.configure(testCommonConfig)
        doc.dependsOn(sphinx)
    }
}
